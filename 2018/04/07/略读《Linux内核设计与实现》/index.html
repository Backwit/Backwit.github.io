<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		略读《Linux内核设计与实现》 | 
	 
	Backwit
	</title>
	
	<!-- keywords,description -->
	 
		<meta name="description" content="Just for Fun" />
	

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	
  

	<link rel="stylesheet" href="/css/main.css">
	<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>
	<script src="/js/main.js"></script>
	
		<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>
	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
</head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">Backwit</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
		
		<li class="menu-item">
			<a href="https://github.com/wujun234/uid-generator-spring-boot-starter" class="menu-item-link" target="_blank">
				UidGenerator
			</a>
		</li>
		<li class="menu-item">
			<a href="https://github.com/wujun234" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="text" placeholder="search...">
		<div id="tree">
			

			
							<ul>
								<li class="file">
									<a href="/2018/12/11/C++ 并行编程之原子操作的内存顺序/">
										C++ 并行编程之原子操作的内存顺序
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2018/03/24/Hexo常用命令/">
										Hexo常用命令
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2018/03/25/container_of详解/">
										container_of详解
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2018/04/07/略读《Linux内核设计与实现》/">
										略读《Linux内核设计与实现》
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	略读《Linux内核设计与实现》
</h1>
<div class="article-meta">
	
	<span>Backwit</span>
	<span>2018-04-07 16:35:22</span>
    
		<div id="article-categories">
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true"></i>
                        <a href="/categories/Linux/">Linux</a>
						
                    </span>
                
            
		</div>
    
</div>

<div id="article-content">
	<p>用了半个月的时间粗略的过了一遍《Linux内核设计与实现》。确实讲的都是理论的知识，比较通俗易懂吧！这里简单的记录一下，主要的内容，以供后面进一步的学习和回顾。</p>
<a id="more"></a>
<hr>
<h2 id="第二章-从内核出发"><a href="#第二章-从内核出发" class="headerlink" title="第二章 从内核出发"></a>第二章 从内核出发</h2><p>本章主要介绍了内核代码的获取，编译，开发注意的事项。</p>
<h3 id="2-1-内核源码树的结构"><a href="#2-1-内核源码树的结构" class="headerlink" title="2.1 内核源码树的结构"></a>2.1 内核源码树的结构</h3><ul>
<li>arch：这个为目录存放的是与CPU架构相关的文件，每个子目录代表了一种CPU架构，比如arm，x86，MIPS，PPC等。</li>
<li>block：部分块设备的驱动程序。</li>
<li>crypto：这个目录下放了一些各种常见的加密算法的C语言代码实现。譬如crc32、md5、sha1等。</li>
<li>Documentation：关于内核各部分的通用解释和注释。</li>
<li>drivers：驱动目录，里面分门别类的列出了linux内核支持的所有硬件设备的驱动源代码。</li>
<li>firmware：固件。某些驱动程序所需的设备固件。</li>
<li>fs：fs就是file system，文件系统，里面列出了linux支持的各种文件系统的实现。</li>
<li>include：头文件目录，公共的（各种CPU架构共用的）头文件都在这里。</li>
<li>init：linux内核启动时初始化内核的代码。（注意不是系统引导代码）</li>
<li>ipc：ipc就是inter process commuication，进程间通信的代码。</li>
<li>kernel：内核的最核心部分，包括进程调度、定时器等，和平台相关的一部分代码放在arch/*/kernel目录下。</li>
<li>lib：一些公用的有用的库函数，注意这里的库函数和C语言的库函数不一样的。在内核编程中是不能用C语言标准库函数，这里的lib目录下的库函数就是用来替代那些标准库函数的。譬如在内核中要把字符串转成数字用atoi，但是内核编程中只能用lib目录下的atoi函数，不能用标准C语言库中的atoi。譬如在内核中要打印信息时不能用printf，而要用printk，这个printk就是我们这个lib目录下的。</li>
<li>mm：memory management，内存管理子系统和VM，和平台相关的一部分代码放在arch/*/mm目录下。</li>
<li>net：网络相关代码，实现了各种常见的网络协议，譬如TCP/IP协议栈等都在这里。</li>
<li>samples：一些例子程序。</li>
<li>scripts：用于配置内核文件的脚本文件。</li>
<li>security：主要是一个SELinux的模块。</li>
<li>sound：常用音频设备的驱动程序等。</li>
<li>tools：linux中用到的一些有用工具。</li>
<li>usr：目录下是initramfs相关的，和linux内核的启动有关。</li>
<li>virt：虚拟化基础结构。</li>
<li>Kbuild：kernel build的意思，就是内核编译的意思。这个文件就是linux内核特有的内核编译体系需要用到的文件。</li>
<li>Makefile：这个是linux内核的总makefile。</li>
</ul>
<h3 id="2-2-内核编译"><a href="#2-2-内核编译" class="headerlink" title="2.2 内核编译"></a>2.2 内核编译</h3><p>1.内核配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用的有：</span><br><span class="line">make menuconfig ## 图形界面配置</span><br><span class="line">make defconfig ## 默认配置</span><br><span class="line">make oldconfig ## 拷贝原来的内核源码树的根目录的 .config 文件用来编译</span><br></pre></td></tr></table></figure></p>
<p>2.内核编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">make [-j #]</span><br><span class="line">make modules_install</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3-其他开发注意事项"><a href="#2-3-其他开发注意事项" class="headerlink" title="2.3 其他开发注意事项"></a>2.3 其他开发注意事项</h3><p>1.内核不能使用标准c库<br>2.不要轻易使用浮点数<br>3.内核栈很小（之前写驱动的时候，定义了一个很大的数组，把内核栈爆了。）</p>
<h2 id="第三章-进程管理"><a href="#第三章-进程管理" class="headerlink" title="第三章 进程管理"></a>第三章 进程管理</h2><p>这一章主要讲了进程的基本概念，进程的状态，进程的创建于销毁。</p>
<h3 id="3-1-进程描述符（process-descriptor）"><a href="#3-1-进程描述符（process-descriptor）" class="headerlink" title="3.1 进程描述符（process descriptor）"></a>3.1 进程描述符（process descriptor）</h3><p>进程描述符对应的一个进程或者是线程，其实质就是 task_struct 结构体。定义在 linux/sched.h 中。</p>
<h3 id="3-2-进程的状态"><a href="#3-2-进程的状态" class="headerlink" title="3.2 进程的状态"></a>3.2 进程的状态</h3><p>进程有五种状态：运行（TASK_RUNNING）、可中断（TASK_INTERRUPTIBLE）、不可中断（TASK_UNINTERRUPTIBLE）、被其他进程跟踪（__TASK_TRACED）、停止（__TASK_STOPPED）。</p>
<ol>
<li>R (TASK_RUNNING)，可执行状态&amp;运行状态(在run_queue队列里的状态)</li>
<li>S (TASK_INTERRUPTIBLE)，可中断的睡眠状态, 可处理signal</li>
<li>D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态,　可处理signal,　有延迟。不可中断态通常处于的时间较短，等待的事件很快就会出现。</li>
<li>T (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态,　不可处理signal,　因为根本没有时间片运行代码</li>
<li>Z (TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程。不可被kill,　即不响应任务信号,　无法用SIGKILL杀死</li>
</ol>
<p><img src="/img/Flow_chart_of _process_states.bmp" alt="Flow_chart_of _process_states.bmp"></p>
<h3 id="3-3-进程的创建与销毁"><a href="#3-3-进程的创建与销毁" class="headerlink" title="3.3 进程的创建与销毁"></a>3.3 进程的创建与销毁</h3><p>进程的创建主要有 fork、vfork、exec。进程的终止主要是exit。创建和终止的原理都比较简单，创建时主要是拷贝主要的数据结构，然后终止的时候，这是要注意资源回收。这里主要说说，写时拷贝和孤儿进程和僵尸进程。</p>
<p><strong>写时拷贝</strong>（copy-on-write）：简单的说就是延时拷贝，当创建一个新的进程时，它们通过共享内存的方式使用同一块内存，当有一个要修改此内存空间的时候，才开始真正的复制一块内存。</p>
<p>进程终止时，资源回收和进程描述符的删除是分开的，先是回收了资源,仅保留了<strong>内核栈、thread_info、task_struct</strong> 这部分的资源，存在的主要的目的是向父进程提供信息。当父进程收到信息后，才释放这一部分的资源。<br>如果父进程在子进程之前退出，子进程处于僵尸状态，还保留着这些资源，白白浪费系统资源，所以要为其找新的父进程。找新的父进程的过程，先在线程组（这个概念还没搞懂，尴尬）中找，没找到就给init进程收养。</p>
<h2 id="第四章-进程调度"><a href="#第四章-进程调度" class="headerlink" title="第四章 进程调度"></a>第四章 进程调度</h2><p>进程调度，即决定将哪个进程投入到运行。</p>
<h3 id="4-1-IO消耗型和处理器消耗型的进程"><a href="#4-1-IO消耗型和处理器消耗型的进程" class="headerlink" title="4.1 IO消耗型和处理器消耗型的进程"></a>4.1 IO消耗型和处理器消耗型的进程</h3><p>IO消耗型的进程：大多数的时间都在等待io，真正需要CPU的时间较少。<br>处理器型的进程：主要的时间都花在了代码执行上。<br>有些进程既属于IO消耗型也属于处理器消耗型，如字处理器，既要等到io输入，又可能需要处理器去进行拼音检查或者宏计算。</p>
<p>中文版第三版书中P39页的例子非常好，关于这个CFS算法，对于IO消耗型和服务器型进程的调度，当有io请求时，立刻响应，调度io消耗型的进程，当其运行完，继续等待io时，立刻调度服务器型的进程。虽然在CFS算法中，为它们都分配了50%的CPU时间。</p>
<h3 id="4-2-关于nice值和进程优先级"><a href="#4-2-关于nice值和进程优先级" class="headerlink" title="4.2 关于nice值和进程优先级"></a>4.2 关于nice值和进程优先级</h3><ol>
<li>nice值越小，优先级越高。pri值越高，优先级越高。</li>
<li>Linux有两种实时调度策略 SCHED_FIFO 和 SHCED_RR。还有非实时调度策略 SCHED_NORMAL。</li>
<li>实时优先级 0-99，非实时的 100-139。nice值表示的是非实时的，范围从-20到+19。映射到实时上就是100-139。</li>
<li>用ps看到的nice值是经过ps这个程序处理的，但是相对的优先级关系还是一样的，小的nice优先级更高。</li>
<li>nice对应的是相对的处理器时间</li>
</ol>
<h3 id="4-3-Linux调度器的实现"><a href="#4-3-Linux调度器的实现" class="headerlink" title="4.3 Linux调度器的实现"></a>4.3 Linux调度器的实现</h3><p>写这一部分，主要是可以帮助了解调度的关键地方。<br>实现主要有：</p>
<ul>
<li><strong>时间记账</strong>：记录进程运行的时间</li>
<li><strong>进程选择</strong>：选择下一个执行的进程</li>
<li><strong>调度器入口</strong></li>
<li><strong>睡眠和唤醒</strong>：休眠的进程（中断和不可中断态）在等待某些条件，不应该被调度的，唤醒是当它们等到之后，将其移除等待队列，使其可以被调度。</li>
</ul>
<h3 id="4-4-其他"><a href="#4-4-其他" class="headerlink" title="4.4 其他"></a>4.4 其他</h3><ol>
<li>抢占</li>
</ol>
<ul>
<li><strong>用户抢占</strong>：从内核空间返回用户空间时发生的抢占。从内核返回时，既可以执行本进程，也可以调度新的进程。有两种情况: <strong>从系统调用返回时</strong>，<strong>从中断处理程序返回时</strong>。</li>
<li><strong>内核抢占</strong>：1）中断程序正在执行，且返回内核空间（没懂？？); 2）内核代码再次具有可抢占性的时候（preempt_count == 0); 3) 显式调用schedule(); 4) 任务阻塞时。</li>
</ul>
<ol>
<li>绑定处理器的调度<br>之前遇到过这样的问题，让一部分程序在特定的核上执行。</li>
</ol>
<h2 id="第五章-系统调用"><a href="#第五章-系统调用" class="headerlink" title="第五章 系统调用"></a>第五章 系统调用</h2><p>主要讲了系统调用的实现，之前做过写过一个系统调用的demo。这里就略掉。</p>
<h2 id="第六章-内核数据结构"><a href="#第六章-内核数据结构" class="headerlink" title="第六章 内核数据结构"></a>第六章 内核数据结构</h2><p>内核实现的一些数据结构，知道主要的，后面再用一下。</p>
<ul>
<li>链表 list</li>
<li>队列 kfifo</li>
<li>映射 idr</li>
<li>二叉树 二叉搜索树、红黑树</li>
</ul>
<h2 id="第七章-中断和中断处理函数"><a href="#第七章-中断和中断处理函数" class="headerlink" title="第七章 中断和中断处理函数"></a>第七章 中断和中断处理函数</h2><p>中断的实现，搞了1年，略了。主要是上下半部分的实现，没用过，都是在上半部分做的。</p>
<ul>
<li>中断：由硬件引起的</li>
<li>异常：同步中断，由软件引起，如除0，缺页。</li>
</ul>
<p>后面是引用的这个博客： <a href="https://blog.csdn.net/liusirboke/article/details/49681625" target="_blank" rel="noopener">https://blog.csdn.net/liusirboke/article/details/49681625</a></p>
<h3 id="7-1-中断上下文和进程上下文的区别？"><a href="#7-1-中断上下文和进程上下文的区别？" class="headerlink" title="7.1 中断上下文和进程上下文的区别？"></a>7.1 中断上下文和进程上下文的区别？</h3><p>1.进程上下文：</p>
<p>（1）进程上文：其是指进程由用户态切换到内核态是需要保存用户态时cpu寄存器中的值，进程状态以及堆栈上的内容，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。</p>
<p>（2）进程下文：其是指切换到内核态后执行的程序，即进程运行在内核空间的部分。</p>
<p>2.中断上下文：</p>
<p>（1）中断上文：硬件通过中断触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。中断上文可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被中断的进程环境。</p>
<p>（2）中断下文：执行在内核空间的中断服务程序。</p>
<h3 id="7-2-为什么要进行不同之间状态的切换"><a href="#7-2-为什么要进行不同之间状态的切换" class="headerlink" title="7.2 为什么要进行不同之间状态的切换"></a>7.2 为什么要进行不同之间状态的切换</h3><p>在现在操作系统中，内核功能模块运行在内核空间，而应用程序运行在用户空间。现代的CPU都具有不同的操作模式，代表不同的级别，不同的级别具有不同的功能，其所拥有的资源也不同；在较低的级别中将禁止使用某些处理器的资源。Linux系统设计时利用了这种硬件特性，使用了两个级别，最高级别和最低级别，内核运行在最高级别（内核态），这个级别几乎可以使用处理器的所有资源，而应用程序运行在较低级别（用户态），在这个级别的用户不能对硬件进行直接访问以及对内存的非授权访问。内核态和用户态有自己的内存映射，即自己的地址空间。</p>
<p>当工作在用户态的进程想访问某些内核才能访问的资源时，必须通过系统调用或者中断切换到内核态，由内核代替其执行。进程上下文和中断上下文就是完成这两种状态切换所进行的操作总称。我将其理解为保存用户空间状态是上文，切换后在内核态执行的程序是下文。</p>
<h3 id="7-3-什么情况下进行用户态到内核态的切换"><a href="#7-3-什么情况下进行用户态到内核态的切换" class="headerlink" title="7.3 什么情况下进行用户态到内核态的切换"></a>7.3 什么情况下进行用户态到内核态的切换</h3><p>1.进程上下文主要是异常处理程序和内核线程。内核之所以进入进程上下文是因为进程自身的一些工作需要在内核中做。例如，系统调用是为当前进程服务的，异常通常是处理进程导致的错误状态等。</p>
<p>2.中断上下文是由于硬件发生中断时会触发中断信号请求，请求系统处理中断，执行中断服务子程序。</p>
<h3 id="7-4-中断上下文代码中注意事项"><a href="#7-4-中断上下文代码中注意事项" class="headerlink" title="7.4 中断上下文代码中注意事项"></a>7.4 中断上下文代码中注意事项</h3><p>运行于进程上下文的内核代码是可抢占的，但中断上下文则会一直运行至结束，不会被抢占。所以中断处理程序代码要受到一些限制，在中断代码中不能出现实现下面功能的代码：</p>
<p>（1）睡眠或者放弃CPU。<br><strong>因为内核在进入中断之前会关闭进程调度，一旦睡眠或者放弃CPU，这时内核无法调度别的进程来执行，系统就会死掉。</strong>牢记：中断服务子程序一定不能睡眠（或者阻塞）。</p>
<p>（2）尝试获得信号量<br>如果获得不到信号量，代码就会睡眠，导致（1）中的结果。</p>
<p>（3）执行耗时的任务<br>中断处理应该尽可能快，因为如果一个处理程序是IRQF_DISABLED类型，他执行的时候会禁止所有本地中断线，而内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。中断处理程序的任务尽可能放在中断下半部执行。</p>
<p>（4）访问用户空间的虚拟地址<br>因为中断运行在内核空间。 </p>
<h2 id="第八章-下半部和推后执行的工作"><a href="#第八章-下半部和推后执行的工作" class="headerlink" title="第八章 下半部和推后执行的工作"></a>第八章 下半部和推后执行的工作</h2><h3 id="8-1-什么是下半部？"><a href="#8-1-什么是下半部？" class="headerlink" title="8.1 什么是下半部？"></a>8.1 什么是下半部？</h3><p>因为中断处理程序以异步的方式执行。可能打断了重要的代码。同时中断也不能被阻塞。要求中断处理要快速。所以这里把中断分成了两个部分，上半部用来处理和硬件密切相关的操作，下半部用来处理与时间要求不高的任务。中断处理完这个中断处理程序就返回了。</p>
<h3 id="8-2-什么时候使用下半部？"><a href="#8-2-什么时候使用下半部？" class="headerlink" title="8.2 什么时候使用下半部？"></a>8.2 什么时候使用下半部？</h3><p>除以下的情况外，其他情况考虑放置在下半部执行。</p>
<ul>
<li>任务对时间非常敏感，放在中断处理程序中；</li>
<li>任务和硬件相关，放在中断处理程序中；</li>
<li>任务要求不能被其他中断打断，放在中断处理程序中。</li>
</ul>
<h3 id="8-3-常用的方式"><a href="#8-3-常用的方式" class="headerlink" title="8.3 常用的方式"></a>8.3 常用的方式</h3><p>都没有用过，记下来有这几种，后面再看。</p>
<ul>
<li>软中断</li>
<li>tasklet</li>
<li>工作队列</li>
</ul>
<h2 id="第九、十章-内核同步"><a href="#第九、十章-内核同步" class="headerlink" title="第九、十章 内核同步"></a>第九、十章 内核同步</h2><h3 id="9-1-为什么要同步？"><a href="#9-1-为什么要同步？" class="headerlink" title="9.1 为什么要同步？"></a>9.1 为什么要同步？</h3><p>主要的原因，多个任务并发执行，并操作了共享数据。而并发执行的原因，是因为抢占和进程调度。常见的并发执行的原因：中断，软中断和tasklet,内核抢占，对称多处理，睡眠及与用户空间的同步（进程睡眠，唤醒一个新的进程开始工作）。</p>
<p>临界区：访问和操作共享数据的代码。</p>
<h3 id="9-2-同步方法"><a href="#9-2-同步方法" class="headerlink" title="9.2 同步方法"></a>9.2 同步方法</h3><p>主要加锁。但注意死锁。</p>
<p>避免死锁：</p>
<ol>
<li>顺序加锁</li>
<li>防止发生饥饿</li>
<li>不要重复请求同一个锁</li>
<li>设计简单点</li>
</ol>
<p>锁的类型：</p>
<ol>
<li>原子操作</li>
<li>自旋锁</li>
<li>读写自旋锁</li>
<li>信号量</li>
<li>读写信号量</li>
<li>互斥量</li>
<li>完成变量</li>
<li>BLK 大内核锁</li>
<li>顺序锁</li>
</ol>
<p>有一个比较有意思的——<strong>顺序</strong>：代码不一定按代码的顺序执行的。避免这种情况的有个<strong>屏障</strong>的机制。</p>
<h2 id="第十一章-定时器和时间管理"><a href="#第十一章-定时器和时间管理" class="headerlink" title="第十一章 定时器和时间管理"></a>第十一章 定时器和时间管理</h2><p>主要讲了个定时器，略了。</p>
<h2 id="第十二章-内存管理"><a href="#第十二章-内存管理" class="headerlink" title="第十二章 内存管理"></a>第十二章 内存管理</h2><p>越写越觉得这本书写的简单。。（是我飘起来了吗？）</p>
<h3 id="12-1-zone（区）"><a href="#12-1-zone（区）" class="headerlink" title="12.1 zone（区）"></a>12.1 zone（区）</h3><p>内核的内存（3G-4G的区域）</p>
<ul>
<li>ZONE_DMA : 0-16M</li>
<li>ZONE_NORMAL : 16-896M</li>
<li>ZONE_HIGHEM : “高端内存” &gt;896M</li>
</ul>
<h3 id="12-2-一些分配函数"><a href="#12-2-一些分配函数" class="headerlink" title="12.2 一些分配函数"></a>12.2 一些分配函数</h3><ul>
<li>页的分配和释放：alloc_pages()、free_pages()</li>
<li>kmalloc(): 物理内存地址连续</li>
<li>vmalloc()：物理内存地址不一定连续</li>
<li>slab：特别有意思，按数据结构分配</li>
</ul>
<h3 id="12-3-高端内存映射——永久映射和临时映射"><a href="#12-3-高端内存映射——永久映射和临时映射" class="headerlink" title="12.3 高端内存映射——永久映射和临时映射"></a>12.3 高端内存映射——永久映射和临时映射</h3><p>隐约有点理解了为什么分为两种，临时映射是必须的，因为内存不够，必须动态的映射。</p>
<h2 id="第十三章-虚拟文件系统"><a href="#第十三章-虚拟文件系统" class="headerlink" title="第十三章 虚拟文件系统"></a>第十三章 虚拟文件系统</h2><ul>
<li>超级块对象 （文件系统）</li>
<li>索引节点对象 （文件的创建 链接）</li>
<li>目录项对象 （目录）</li>
<li>文件对象 （进程打开的文件）</li>
</ul>
<h2 id="第十四章-块I-O层"><a href="#第十四章-块I-O层" class="headerlink" title="第十四章 块I/O层"></a>第十四章 块I/O层</h2><p>对块设备的操作，对IO的操作很慢，IO调度的主要工作就是为了减少磁盘寻址时间，主要的方式合并与排序。合并相邻的操作。</p>
<h2 id="第十五章-进程地址空间"><a href="#第十五章-进程地址空间" class="headerlink" title="第十五章 进程地址空间"></a>第十五章 进程地址空间</h2><h2 id="第十六章-页高速缓存和页回写"><a href="#第十六章-页高速缓存和页回写" class="headerlink" title="第十六章 页高速缓存和页回写"></a>第十六章 页高速缓存和页回写</h2><p>也是为了解决磁盘读写慢的缺点，将磁盘的区域映射到内存，然后这里考虑的是什么时候写回到磁盘。（sync的作用）</p>
<h2 id="第十七章-设备与模块"><a href="#第十七章-设备与模块" class="headerlink" title="第十七章 设备与模块"></a>第十七章 设备与模块</h2><h2 id="第十八章-调试"><a href="#第十八章-调试" class="headerlink" title="第十八章 调试"></a>第十八章 调试</h2><ul>
<li>oops</li>
<li>dmesg</li>
<li>神奇的系统请求键 （echo 1 &gt; /proc/sys/kernel/sysrq）</li>
<li>gdb kgdb</li>
</ul>
<h2 id="第十九章-可移植性"><a href="#第十九章-可移植性" class="headerlink" title="第十九章 可移植性"></a>第十九章 可移植性</h2><ul>
<li>字节和数据类型的长度</li>
<li>字节对齐</li>
<li>字节顺序 大端和小端</li>
<li>时间 HZ</li>
<li>页大小</li>
</ul>

</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2018/12/11/C++ 并行编程之原子操作的内存顺序/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  C++ 并行编程之原子操作的内存顺序
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2018/03/25/container_of详解/">
                container_of详解
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>



	<div id="vcomments"></div>


<script>
	
		// 评论
		new Valine({
			av: AV,
			el: '#vcomments',
			notify: false,
			verify: false,
			path: window.location.pathname,
			appId: '',
			appKey: '',
			placeholder: '请输入评论',
			avatar: 'retro',
			recordIP: false
		})
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">Backwit</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>